DROP TABLE IF EXISTS "accounts";

CREATE TABLE "accounts" (
    "id" INT GENERATED BY DEFAULT AS IDENTITY,
    "name" VARCHAR(100) NOT NULL,
    "balance" DEC(15,2) NOT NULL,
    PRIMARY KEY("id")
);

INSERT INTO "accounts"("name", "balance")
VALUES('Bob', 10000);

BEGIN; -- Start of a transaction 

INSERT INTO "accounts"("name", "balance")
VALUES('Alice', 10000);

SELECT "id", "name", "balance" FROM "accounts";


COMMIT; -- end of a transaction 

-- STATEMENT: Create a transaction which debits 500 from the account balance for account 2

BEGIN;

UPDATE "accounts" SET "balance" = "balance"-500 WHERE "id"=2;
UPDATE "accounts" SET "balance" = "balance"+500 WHERE "id"=3;
COMMIT;


-- ROLLBACK JAVA DRIVEN WE WILL ROLLBACK BASE ON JAVA CONDITION 

-- Begin the transaction
BEGIN;

-- deduct the amount from account 2 (Alice)
UPDATE "accounts" 
SET "balance" = "balance" - 1500
WHERE "id" = 2;

-- Accidentally add the amount to account 3 (Jack) [instead of account 1 (Bob)]
UPDATE "accounts"
SET "balance" = "balance" + 1500
WHERE "id" = 3; 

-- Uh oh. Bobâ€™s account has an id of 1. This was a mistake.

-- To undo the change, you simply execute the ROLLBACK statement:

-- Roll it back:
ROLLBACK;

-- Now if we check our balances, they have returned to the states they were in before the transaction.

-- Select the data from accounts to check that everything is back to normal:
SELECT "id", "name", "balance" FROM "accounts";


-- SAVE POINT 

-- This code will be committed no matter what, because we've run the COMMIT command:
INSERT INTO "accounts" VALUES('Alice', 10000);
COMMIT;

-- This code is uncommitted, but we do establish a SAVEPOINT:
UPDATE "accounts" 
SET "balance" = "balance" - 1500;
WHERE "id" = 1;

SAVEPOINT A;

-- This code doesn't belong to SAVEPOINT A. It will only be reflected if we COMMIT or ROLLBACK TO B:
INSERT INTO "accounts" VALUES('Bob', 15000);

SAVEPOINT B;

-- This code doesn't belong to SAVEPOINT A or B. It will only be reflected if we COMMIT or ROLLBACK TO C:
INSERT INTO "accounts" VALUES('Carlos', 12000);

SAVEPOINT C;

-- This command effectively returns our code to the state it was in when line 10 was run:


-- TRIGGERS 

CREATE FUNCTION addFiveDollars() RETURNS TRIGGER AS
$$ 
	BEGIN
	UPDATE "accounts" SET "balance" = "balance"-5;

	END
$$ LANGUAGE plpgsql;

CREATE TRIGGER triggerFiveDollarBonus AFTER UPDATE ON  accounts 
FOR EACH ROW EXECUTE PROCEDURE addFiveDollars();
